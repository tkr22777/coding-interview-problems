
import java.io.*;
import java.util.*;
import java.util.stream.*;

class Solution {

  public static void main(String[] args) {
    int[][] graph = {{1,1,0},
                     {1,1,0},
                     {0,0,1}
                    };
    int[] initial = {0,1};

    System.out.println(new Solution().minMalwareSpread(graph, initial));
  }

   public int minMalwareSpread(int[][] graph, int[] initial) {
        //find the node that would minimize infected nodes if it was not on initial
        Set<Integer> infectedNodes = Arrays.stream(initial).boxed().collect(Collectors.toSet());
        Arrays.stream(graph).forEach( v -> System.out.println(Arrays.toString(v)));

        Map<Integer, Set<Integer>> nodeToGroupMap = new HashMap<Integer, Set<Integer>>();
        for (int node = 0; node < graph.length; node++) {
            Set<Integer> groupA = nodeToGroupMap.computeIfAbsent(node, v -> new HashSet<Integer>());
            groupA.add(node);
            for (int next = 0; next < graph[node].length; next++) {
                if (graph[node][next] == 1) {
                    groupA.add(next);
                    Set<Integer> groupNext = nodeToGroupMap.computeIfAbsent(next, v -> groupA);
                    if (groupNext != groupA) {
                        groupA.addAll(groupNext);
                    }
                }
            }
        }

        /*
        nodeToGroupMap.keySet().stream().forEach(k ->
          System.out.println("K:" + k + " S:" + nodeToGroupMap.get(k))
        );
        */

        HashSet<Set<Integer>> nodeGroupSet = new HashSet<Set<Integer>>(nodeToGroupMap.values());

        int nodeToRemove = Arrays.stream(initial).min().orElse(-1);
        int maxNodes = nodeGroupSet.iterator().next().size();
        for (Set<Integer> aGroupSet: nodeGroupSet) {
            int size = aGroupSet.size();
            aGroupSet.retainAll(infectedNodes);
            if (aGroupSet.size() == 1) {
                int candidateNode = aGroupSet.iterator().next();
                if (size > maxNodes)  {
                    maxNodes = size;
                    nodeToRemove = candidateNode;
                } else if (size == maxNodes && nodeToRemove > candidateNode) {
                    nodeToRemove = candidateNode;
                }
            }
        }

        return nodeToRemove;
    }
}


