import java.util.*;
import java.util.stream.*;

/* https://leetcode.com/problems/minimize-malware-spread/ */

/* TODO add explanation, punting, still so confused and a hard problem */
class Solution {

  public static void main(String[] args) {
      int[] initial = {0, 1};
      int[][] graph = { // n x n adjacency matrix for the graph, thus the diagonal is 1
          {1, 1, 0},
          {1, 1, 0},
          {0, 0, 1},
      };
      System.out.println(new Solution().minMalwareSpread(graph, initial));
  }

   public int minMalwareSpread(int[][] graph, int[] initial) {
        //find the node that would minimize infected nodes if it was not on initial
        Set<Integer> infectedNodes = Arrays.stream(initial).boxed().collect(Collectors.toSet());
        Arrays.stream(graph).forEach(v -> System.out.println(Arrays.toString(v)));

        Map<Integer, Set<Integer>> nodeToGroupMap = new HashMap<Integer, Set<Integer>>();
        for (int node = 0; node < graph.length; node++) {
            Set<Integer> nodeGroup = nodeToGroupMap.computeIfAbsent(node, v -> new HashSet<Integer>());
            nodeGroup.add(node); //group should have the node itself

            for (int next = 0; next < graph[node].length; next++) {
                if (graph[node][next] == 1) {
                    nodeGroup.add(next); //and the next nodes
                    Set<Integer> groupNext = nodeToGroupMap.computeIfAbsent(next, v -> nodeGroup);
                    if (groupNext != nodeGroup) {
                        nodeGroup.addAll(groupNext);
                    }
                }
            }
        }

        /*
        nodeToGroupMap.keySet().stream().forEach(k ->
          System.out.println("K:" + k + " S:" + nodeToGroupMap.get(k)));
        */

        HashSet<Set<Integer>> nodeGroupSet = new HashSet<Set<Integer>>(nodeToGroupMap.values());
        //remove the first node by default
        int nodeToRemove = Arrays.stream(initial).min().orElse(-1); 
        int maxNodes = nodeGroupSet.iterator().next().size();
        for (Set<Integer> aGroupSet: nodeGroupSet) {
            int size = aGroupSet.size();
            aGroupSet.retainAll(infectedNodes);
            //it only makes sense to remove a single affected node
            if (aGroupSet.size() == 1) { 
                int candidateNode = aGroupSet.iterator().next();
                if (size > maxNodes) {
                    maxNodes = size;
                    nodeToRemove = candidateNode;
                } else if (size == maxNodes && nodeToRemove > candidateNode) {
                    nodeToRemove = candidateNode;
                }
            }
        }

        return nodeToRemove;
    }
}

